<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NetCDF Raster Sandbox (Portable)</title>
    <!-- External Dependencies via CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        html, body, #root { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif; 
            background-color: #f0f2f5; color: #333; 
        }
        .main-layout { display: flex; height: 100vh; }
        .sidebar { width: 320px; min-width: 300px; padding: 1rem; background-color: #fff; border-right: 1px solid #ddd; overflow-y: auto; box-shadow: 2px 0 5px rgba(0,0,0,0.1); z-index: 20; }
        .content-grid { flex-grow: 1; display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 8px; padding: 8px; background-color: #e9ecef; overflow-y: auto; }
        .view-container { display: flex; flex-direction: column; background-color: #495057; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); overflow: hidden; min-height: 300px; position: relative; }
        .view-header { background-color: #343a40; color: white; padding: 6px 12px; font-size: 0.9rem; font-weight: bold; display: flex; justify-content: space-between; align-items: center; }
        .view-header-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 10px; }
        .view-header-buttons { display: flex; gap: 5px; }
        .view-btn { background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; padding: 2px 6px; font-size: 14px; line-height: 1; }
        .view-btn:disabled { background: #495057; cursor: not-allowed; opacity: 0.5; }
        .view-btn-close { background: #dc3545; }
        .view-canvas-wrapper { flex-grow: 1; position: relative; overflow: hidden; }
        
        .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.75); color: white; display: flex; justify-content: center; align-items: center; z-index: 2000; }
        .loading-content { text-align: center; font-size: 1.2rem; padding: 2rem; background: rgba(0,0,0,0.5); border-radius: 8px; min-width: 250px; }
        .progress-bar-container { margin-top: 1rem; width: 100%; height: 20px; background-color: #555; border-radius: 5px; border: 1px solid #777; overflow: hidden; }
        .progress-bar { width: 0%; height: 100%; background-color: #28a745; text-align: center; line-height: 20px; color: white; font-weight: bold; font-size: 12px; transition: width 0.2s ease-out; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 3000; }
        .modal-content { background-color: white; padding: 1.5rem; border-radius: 8px; width: 600px; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
        .metadata-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; margin-top: 5px; }
        .metadata-table th, .metadata-table td { padding: 8px; border: 1px solid #ddd; text-align: left; word-break: break-word; }
        .metadata-table tr:nth-child(even) { background-color: #f9f9f9; }
        .metadata-key { font-weight: bold; color: #555; width: 35%; }
        .info-icon { cursor: pointer; opacity: 0.6; margin-left: 8px; font-size: 1.1em; vertical-align: middle; transition: opacity 0.2s; }
        .info-icon:hover { opacity: 1; color: #007bff; }
        
        .notification-container { position: fixed; bottom: 20px; right: 20px; z-index: 4000; display: flex; flex-direction: column; gap: 10px; }
        .notification-toast { display: flex; justify-content: space-between; align-items: center; padding: 12px 18px; border-radius: 5px; color: #fff; box-shadow: 0 3px 10px rgba(0,0,0,0.2); min-width: 250px; }
        .notification-info { background-color: #2f96b4; }
        .notification-success { background-color: #51a351; }
        .notification-error { background-color: #bd362f; }
        
        .attribution-footer { padding: 4px; text-align: center; background: #e9ecef; border-top: 1px solid #ddd; }
        .attribution-text { background: rgba(255,255,255,0.8); padding: 5px 10px; border-radius: 3px; font-size: 10px; color: #333; box-shadow: 0 1px 3px rgba(0,0,0,0.15); display: inline-block; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import * as Comlink from 'https://esm.sh/comlink@4.4.1';
        import * as h5wasm from 'https://esm.sh/h5wasm@0.8.1';
        import * as topojson from 'https://esm.sh/topojson-client@3.1.0';

        const { useState, useEffect, useCallback, useMemo, useRef, createContext, useContext } = React;

        // --- GEOSPATIAL LOGIC (RAW WORKER STRING) ---
        const workerCode = `
            importScripts('https://unpkg.com/comlink/dist/umd/comlink.js');
            
            const calculateLatLon = (dataset) => {
                const globalAttrs = dataset.globalAttributes;
                const vars = dataset.variables;
                
                const r_eq = parseFloat(globalAttrs.semi_major_axis);
                const r_pol = parseFloat(globalAttrs.semi_minor_axis);
                const H = parseFloat(globalAttrs.perspective_point_height) + r_eq;
                const lon_0 = parseFloat(globalAttrs.longitude_of_projection_origin) * (Math.PI / 180);
                
                const y_data = vars.y.data;
                const x_data = vars.x.data;
                
                const r_eq_sq = r_eq * r_eq;
                const r_pol_sq = r_pol * r_pol;
                const lats = new Float32Array(y_data.length * x_data.length);
                const lons = new Float32Array(y_data.length * x_data.length);
                
                let i = 0;
                for (let j = 0; j < y_data.length; j++) {
                    const y_i = y_data[j];
                    const sin_y = Math.sin(y_i); 
                    const cos_y = Math.cos(y_i);
                    for (let k = 0; k < x_data.length; k++) {
                        const x_i = x_data[k];
                        const sin_x = Math.sin(x_i); 
                        const cos_x = Math.cos(x_i);
                        const a = sin_x * sin_x + cos_x * cos_x * (cos_y * cos_y + (r_eq_sq / r_pol_sq) * sin_y * sin_y);
                        const b = -2 * H * cos_x * cos_y;
                        const c = (H * H) - r_eq_sq;
                        const r_s_sqrt = b * b - 4 * a * c;
                        
                        if (r_s_sqrt < 0) { 
                            lats[i] = NaN; 
                            lons[i] = NaN; 
                        } else {
                            const r_s = (-b - Math.sqrt(r_s_sqrt)) / (2 * a);
                            const S_x = r_s * cos_x * cos_y; 
                            const S_y = -r_s * sin_x; 
                            const S_z = r_s * cos_x * sin_y;
                            lats[i] = Math.atan((r_eq_sq / r_pol_sq) * (S_z / Math.sqrt(Math.pow(H - S_x, 2) + Math.pow(S_y, 2)))) * (180 / Math.PI);
                            lons[i] = (lon_0 - Math.atan2(S_y, H - S_x)) * (180 / Math.PI);
                        }
                        i++;
                    }
                }
                return { lats, lons };
            };

            const geoService = {
                process: async (dataset) => {
                    const { lats, lons } = calculateLatLon(dataset);
                    return Comlink.transfer({ lats, lons }, [lats.buffer, lons.buffer]);
                }
            };
            Comlink.expose(geoService);
        `;
        
        const workerBlob = new Blob([workerCode], { type: 'text/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        const geoWorker = new Worker(workerUrl);
        const geoService = Comlink.wrap(geoWorker);

        // --- SPATIAL INDEXING ---

        function createSpatialIndex(lats, lons, dims) {
            if (!lats || !lons) return null;
            const [h, w] = dims;
            const domain = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };
            for(let i=0; i<lats.length; i++) {
                if (isNaN(lats[i])) continue;
                if (lats[i] < domain.minLat) domain.minLat = lats[i];
                if (lats[i] > domain.maxLat) domain.maxLat = lats[i];
                if (lons[i] < domain.minLon) domain.minLon = lons[i];
                if (lons[i] > domain.maxLon) domain.maxLon = lons[i];
            }
            const gridDivs = 100;
            const latStep = (domain.maxLat - domain.minLat) / gridDivs;
            const lonStep = (domain.maxLon - domain.minLon) / gridDivs;
            const grid = Array(gridDivs * gridDivs).fill(null).map(() => []);
            for (let i = 0; i < lats.length; i++) {
                if (isNaN(lats[i])) continue;
                const gy = Math.floor((lats[i] - domain.minLat) / latStep);
                const gx = Math.floor((lons[i] - domain.minLon) / lonStep);
                const idx = Math.max(0, Math.min(grid.length - 1, Math.floor(gy * gridDivs + gx)));
                grid[idx].push(i);
            }
            return { grid, domain, gridDivs, latStep, lonStep, lats, lons, width: w };
        }

        function findClosestPixel(lat, lon, index) {
            if (!index || lat < index.domain.minLat || lat > index.domain.maxLat || lon < index.domain.minLon || lon > index.domain.maxLon) return null;
            const gy = Math.floor((lat - index.domain.minLat) / index.latStep);
            const gx = Math.floor((lon - index.domain.minLon) / index.lonStep);
            const gIdx = Math.max(0, Math.min(index.grid.length - 1, Math.floor(gy * index.gridDivs + gx)));
            const points = index.grid[gIdx];
            if (!points || points.length === 0) return null;
            let best = -1, minDist = Infinity;
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const d = Math.pow(lat - index.lats[p], 2) + Math.pow(lon - index.lons[p], 2);
                if (d < minDist) { minDist = d; best = p; }
            }
            if (Math.sqrt(minDist) > Math.sqrt(Math.pow(index.latStep,2) + Math.pow(index.lonStep,2)) * 2) return null;
            return { x: best % index.width, y: Math.floor(best / index.width) };
        }

        // --- COLORIZER ---

        const colormapDefs = {
            viridis: [[68, 1, 84], [72, 40, 120], [62, 74, 137], [49, 104, 142], [38, 130, 142], [31, 158, 137], [53, 183, 121], [109, 205, 89], [180, 222, 44], [253, 231, 37]],
            jet: [[0, 0, 131], [0, 60, 170], [5, 255, 255], [255, 255, 0], [250, 100, 0], [240, 0, 0], [130, 0, 0]],
            rainbow: [[150, 0, 90], [0, 0, 200], [0, 255, 0], [255, 255, 0], [255, 127, 0], [255, 0, 0]]
        };

        const colorMaps = {
            grayscale: (v, min, max) => {
                if (isNaN(v)) return [0, 0, 0, 0];
                if (min === max) return [128, 128, 128, 255];
                const val = Math.round(((v - min) / (max - min)) * 255);
                return [val, val, val, 255];
            },
            grayscale_r: (v, min, max) => {
                if (isNaN(v)) return [0, 0, 0, 0];
                if (min === max) return [128, 128, 128, 255];
                const val = 255 - Math.round(((v - min) / (max - min)) * 255);
                return [val, val, val, 255];
            }
        };
        Object.keys(colormapDefs).forEach(name => {
            const colors = colormapDefs[name];
            const mapper = (v, min, max, pool) => {
                if (isNaN(v)) return [0, 0, 0, 0];
                if (min === max) return [...pool[0], 255];
                const norm = Math.max(0, Math.min(1, (v - min) / (max - min)));
                const idx = norm * (pool.length - 1);
                const i1 = Math.floor(idx), i2 = Math.ceil(idx), t = idx - i1;
                const r = pool[i1][0] + t * (pool[i2][0] - pool[i1][0]);
                const g = pool[i1][1] + t * (pool[i2][1] - pool[i1][1]);
                const b = pool[i1][2] + t * (pool[i2][2] - pool[i1][2]);
                return [r, g, b, 255];
            };
            colorMaps[name] = (v, min, max) => mapper(v, min, max, colors);
            colorMaps[`${name}_r`] = (v, min, max) => mapper(v, min, max, [...colors].reverse());
        });

        // --- DATA HELPERS & PDF METADATA LOGIC ---

        const extractAttributes = (item) => {
            const obj = {};
            if (item && item.attrs) {
                for (let k in item.attrs) {
                    obj[k] = item.attrs[k].value;
                }
            }
            return obj;
        };

        const formatAttrValue = (val) => {
            if (val === null || val === undefined) return 'N/A';
            if (val.join) return `[${Array.from(val).join(', ')}]`;
            if (typeof val === 'object') return JSON.stringify(val);
            return String(val);
        };

        const findVar = (h5, group, name) => {
            const keys = Array.from(group.keys());
            if (keys.includes(name)) {
                const item = group.get(name);
                if (!(item instanceof h5.Group)) return item;
            }
            for (let k of keys) {
                const item = group.get(k);
                if (item instanceof h5.Group) {
                    const found = findVar(h5, item, name);
                    if (found) return found;
                }
            }
            return null;
        };

        const getDomain = (arr) => {
            let min = Infinity, max = -Infinity;
            for (let i = 0; i < arr.length; i++) {
                const v = arr[i];
                if (!isNaN(v)) { if (v < min) min = v; if (v > max) max = v; }
            }
            return { min, max };
        };

        const unpack = (v, fill) => {
            const raw = v.value;
            const attrs = extractAttributes(v);
            const scale = attrs.scale_factor ? attrs.scale_factor[0] : 1.0;
            const offset = attrs.add_offset ? attrs.add_offset[0] : 0.0;
            const fv = fill && attrs._FillValue ? attrs._FillValue[0] : null;
            const out = new Float32Array(raw.length);
            for(let i=0; i<raw.length; i++) out[i] = (fill && raw[i] === fv) ? NaN : (raw[i] * scale) + offset;
            return out;
        };

        // --- CONTEXTS ---

        const NotificationContext = createContext();
        const useNotifier = () => useContext(NotificationContext);
        const NotificationProvider = ({ children }) => {
            const [notifications, setNotifications] = useState([]);
            const remove = useCallback(id => setNotifications(prev => prev.filter(n => n.id !== id)), []);
            const add = (message, type = 'info') => {
                const id = Date.now() + Math.random();
                setNotifications(prev => [...prev, { id, message, type }]);
                if (type !== 'error') setTimeout(() => remove(id), 5000);
            };
            const api = useMemo(() => ({ info: m => add(m, 'info'), success: m => add(m, 'success'), error: m => add(m, 'error') }), []);
            return (
                <NotificationContext.Provider value={api}>
                    {children}
                    <div className="notification-container">
                        {notifications.map(n => (
                            <div key={n.id} className={`notification-toast notification-${n.type}`}>
                                <span style={{marginRight: '15px'}}>{n.message}</span>
                                <button style={{background:'none',border:'none',color:'white',cursor:'pointer',fontSize:'20px'}} onClick={() => remove(n.id)}>&times;</button>
                            </div>
                        ))}
                    </div>
                </NotificationContext.Provider>
            );
        };

        // --- COMPONENTS ---

        function Uploader({ onNcFileLoaded, onConfigLoaded }) {
            const handleFile = (file) => {
                if (!file) return;
                const ext = file.name.split('.').pop().toLowerCase();
                const reader = new FileReader();
                if (ext === 'json') {
                    reader.onload = (e) => onConfigLoaded(JSON.parse(e.target.result));
                    reader.readAsText(file);
                } else {
                    reader.onload = (e) => onNcFileLoaded(e.target.result, file.name);
                    reader.readAsArrayBuffer(file);
                }
            };
            return (
                <div style={{border:'2px dashed #ccc', padding:'1.5rem', textAlign:'center', cursor:'pointer'}} onClick={() => document.getElementById('file-input').click()} onDragOver={e=>e.preventDefault()} onDrop={e=>{e.preventDefault(); handleFile(e.dataTransfer.files[0])}}>
                    <input type="file" id="file-input" style={{display:'none'}} onChange={e => handleFile(e.target.files[0])} accept=".nc,.json" />
                    <p style={{fontSize: '0.9rem'}}>Drag & drop config (.json) or data (.nc) file here, or click to select.</p>
                </div>
            );
        }

        function MetadataModal({ view, onClose }) {
            if (!view) return null;
            const hasTech = view.tech && Object.keys(view.tech).length > 0;
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div style={{display:'flex', justifyContent:'space-between', borderBottom:'1px solid #ddd', paddingBottom:'10px'}}>
                            <h3 style={{margin:0}}>Metadata: {view.title}</h3>
                            <button onClick={onClose} style={{border:'none',background:'none',fontSize:'24px',cursor:'pointer',lineHeight:1}}>&times;</button>
                        </div>
                        <div style={{marginTop:'15px'}}>
                            {hasTech && (
                                <>
                                    <strong style={{display:'block', marginBottom:'5px'}}>Technical Metadata</strong>
                                    <table className="metadata-table">
                                        <tbody>
                                            {Object.entries(view.tech).map(([k, v]) => (
                                                <tr key={k}><td className="metadata-key">{k}</td><td>{formatAttrValue(v)}</td></tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </>
                            )}
                            <strong style={{display:'block', marginTop:'20px', marginBottom:'5px'}}>Attributes</strong>
                            {view.data && Object.keys(view.data).length > 0 ? (
                                <table className="metadata-table">
                                    <thead><tr><th>Attribute Name</th><th>Value</th></tr></thead>
                                    <tbody>
                                        {Object.entries(view.data).sort().map(([k, v]) => (
                                            <tr key={k}><td className="metadata-key">{k}</td><td>{formatAttrValue(v)}</td></tr>
                                        ))}
                                    </tbody>
                                </table>
                            ) : (
                                <p style={{fontSize:'0.9rem', color:'#666'}}>No attributes found.</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function Colorbar({ units, colormapName, min, max, position }) {
            const canvasRef = useRef(null);
            const style = useMemo(() => {
                const s = { position:'absolute', background:'rgba(0,0,0,0.6)', color:'white', padding:'10px', borderRadius:'5px', zIndex:10, fontSize:'12px', fontFamily:'sans-serif' };
                if (position.includes('top')) s.top = '20px'; else s.bottom = '20px';
                if (position.includes('left')) s.left = '20px'; else s.right = '20px';
                return s;
            }, [position]);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || min === Infinity) return;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createLinearGradient(0, 0, 200, 0);
                const cm = colorMaps[colormapName] || colorMaps.viridis;
                for (let i=0; i<=1; i+=0.01) {
                    const value = (min === max) ? min : min + (max-min)*i;
                    const rgba = cm(value, min, max);
                    if (rgba.some(isNaN)) {
                        grad.addColorStop(i, 'rgba(0,0,0,0)');
                    } else {
                        grad.addColorStop(i, `rgba(${rgba[0]},${rgba[1]},${rgba[2]},${rgba[3]/255})`);
                    }
                }
                ctx.fillStyle = grad; ctx.fillRect(0,0,200,20);
            }, [colormapName, min, max]);
            
            if (min === Infinity) return null;
            return (
                <div style={style}>
                    <div style={{textAlign:'center', marginBottom:'5px'}}>{units}</div>
                    <canvas ref={canvasRef} width="200" height="20" style={{border:'1px solid #fff'}} />
                    <div style={{display:'flex', justifyContent:'space-between', marginTop:'5px'}}><span>{min.toFixed(2)}</span><span>{max.toFixed(2)}</span></div>
                </div>
            );
        }

        function PanZoomControls({ onPan, onZoom, toolMode, onSetToolMode, overlaySettings, onUpdateOverlay, colorMap, onSetColorMap, isColorbarVisible, onToggleColorbar, colorbarPosition, onSetColorbarPosition, onExport, fullDims }) {
            const [pos, setPos] = useState({ x: 20, y: 20 });
            const [dragging, setDragging] = useState(false);
            const offset = useRef({ x:0, y:0 });

            const startDrag = (e) => {
                if (['INPUT', 'SELECT', 'BUTTON', 'LABEL'].includes(e.target.tagName)) return;
                e.stopPropagation();
                setDragging(true);
                offset.current = { x: e.clientX - pos.x, y: e.clientY - pos.y };
            };

            useEffect(() => {
                const move = (e) => {
                    if (!dragging) return;
                    setPos({ x: Math.max(0, e.clientX - offset.current.x), y: Math.max(0, e.clientY - offset.current.y) });
                };
                const stop = () => setDragging(false);
                document.addEventListener('mousemove', move);
                document.addEventListener('mouseup', stop);
                return () => { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', stop); };
            }, [dragging]);

            const btnStyle = { background:'#fff', border:'1px solid #ccc', color:'#333', width:'30px', height:'30px', margin:'2px', cursor:'pointer', fontWeight:'bold', borderRadius:'3px' };
            const blockStyle = { marginTop:'5px', paddingTop:'5px', borderTop:'1px solid #555', width:'100%', display:'flex', flexDirection:'column', gap:'5px' };
            const headerStyle = { fontSize:'11px', fontWeight:'bold', color:'#fff', textAlign:'center', width:'100%', padding:'2px 0', textTransform:'uppercase' };

            return (
                <div style={{ position:'absolute', left:`${pos.x}px`, top:`${pos.y}px`, display:'flex', flexDirection:'column', alignItems:'center', background:'rgba(0,0,0,0.65)', padding:'5px', borderRadius:'5px', color:'white', zIndex:100, width:'130px', cursor:'move', userSelect:'none' }} onMouseDown={startDrag}>
                    <div style={{display:'grid', gridTemplateColumns:'repeat(3, 1fr)', gap:'2px', width:'100px', marginBottom:'5px'}}>
                        <div/><button style={btnStyle} onClick={()=>onPan(0, 40)}>↑</button><div/>
                        <button style={btnStyle} onClick={()=>onPan(40, 0)}>←</button><button style={btnStyle} onClick={()=>onZoom(1)}>⌾</button><button style={btnStyle} onClick={()=>onPan(-40,0)}>→</button>
                        <div/><button style={btnStyle} onClick={()=>onPan(0, -40)}>↓</button><div/>
                    </div>
                    <div style={{display:'flex', justifyContent:'space-between', width:'100%'}}>
                        <button style={btnStyle} onClick={()=>onZoom(1.2)}>+</button>
                        <button style={btnStyle} onClick={()=>onZoom(0.8)}>-</button>
                    </div>
                    
                    <div style={blockStyle}>
                        <div style={headerStyle}>Tool</div>
                        <label style={{fontSize:'11px', cursor:'pointer'}}><input type="radio" checked={toolMode==='pan'} onChange={()=>onSetToolMode('pan')} /> Pan</label>
                        <label style={{fontSize:'11px', cursor:'pointer'}}><input type="radio" checked={toolMode==='picker'} onChange={()=>onSetToolMode('picker')} /> Picker</label>
                    </div>
                    
                    <div style={blockStyle}>
                        <div style={headerStyle}>Map Overlay</div>
                        <button style={{width:'100%', padding:'5px', cursor:'pointer', fontWeight:'bold', borderRadius:'3px'}} onClick={()=>onUpdateOverlay({ visible: !overlaySettings.visible })}>
                            {overlaySettings.visible ? 'Hide Map' : 'Show Map'}
                        </button>
                        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', fontSize:'11px'}}>
                            <label>Color:</label>
                            <input type="color" style={{width:'40px', height:'25px', padding:'1px', cursor:'pointer', background:'transparent', border:'1px solid #555'}} value={overlaySettings.color} onChange={e=>onUpdateOverlay({color: e.target.value})} />
                        </div>
                        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', fontSize:'11px'}}>
                            <label>Width:</label>
                            <input type="range" min="0.5" max="10" step="0.1" style={{width:'60px'}} value={overlaySettings.width} onChange={e=>onUpdateOverlay({width: parseFloat(e.target.value)})} />
                        </div>
                    </div>
                    
                    <div style={blockStyle}>
                        <div style={headerStyle}>Colorbar</div>
                        <select style={{width:'100%', padding:'4px 2px', borderRadius:'3px', cursor:'pointer'}} value={colorMap} onChange={e=>onSetColorMap(e.target.value)}>
                            {Object.keys(colorMaps).sort().map(c => <option key={c} value={c}>{c}</option>)}
                        </select>
                        <button style={{width:'100%', padding:'5px', cursor:'pointer', fontWeight:'bold', borderRadius:'3px'}} onClick={onToggleColorbar}>{isColorbarVisible ? 'Hide Bar' : 'Show Bar'}</button>
                    </div>
                    
                    <div style={blockStyle}>
                        <div style={headerStyle}>Download</div>
                        <button style={{width:'100%', background:'#d4edda', color:'#155724', padding:'4px', fontSize:'10px', cursor:'pointer', borderRadius:'3px'}} onClick={()=>onExport(1)}>Full ({fullDims[1]}x{fullDims[0]})</button>
                        <button style={{width:'100%', background:'#d4edda', color:'#155724', padding:'4px', fontSize:'10px', cursor:'pointer', borderRadius:'3px'}} onClick={()=>onExport(0.5)}>Half</button>
                    </div>
                </div>
            );
        }

        function InteractiveDataView({ layer, colormapName, onSetColorMap, coastlineData, boundaryData, toolMode, onSetToolMode, onPixelPick, onRemove, onReorder, index, totalLayers }) {
            const viewRef = useRef(null);
            const canvasRef = useRef(null);
            const offscreenCanvasRef = useRef(document.createElement('canvas')); 
            
            const [transform, setTransform] = useState({ x:0, y:0, scale:1 });
            const [domain, setDomain] = useState({ min:0, max:1 });
            
            // Decoupled pan dragging refs to fix the frozen/broken pan
            const isPanning = useRef(false);
            const [cursorPanning, setCursorPanning] = useState(false);
            const lastPos = useRef({ x:0, y:0 });
            
            const [overlaySettings, setOverlaySettings] = useState({ visible: true, color: '#00ffff', width: 2.0 });
            const [isCbVisible, setIsCbVisible] = useState(true);
            const [cbPos, setCbPos] = useState('bottom-right');

            const spatialIndex = useMemo(() => layer?.coords ? createSpatialIndex(layer.coords.lats, layer.coords.lons, layer.dims) : null, [layer]);

            useEffect(() => {
                if (!layer || !layer.values) return;
                const d = layer.domain || getDomain(layer.values);
                setDomain(d);
                
                const [h, w] = layer.dims;
                const offscreen = offscreenCanvasRef.current;
                offscreen.width = w;
                offscreen.height = h;
                const offCtx = offscreen.getContext('2d');
                
                const img = offCtx.createImageData(w, h);
                const cm = colorMaps[colormapName] || colorMaps.viridis;
                for (let i=0; i<layer.values.length; i++) {
                    const rgba = cm(layer.values[i], d.min, d.max);
                    img.data[i*4]=rgba[0]; img.data[i*4+1]=rgba[1]; img.data[i*4+2]=rgba[2]; img.data[i*4+3]=rgba[3];
                }
                offCtx.putImageData(img, 0, 0);
                
                if (viewRef.current) {
                    const { clientWidth, clientHeight } = viewRef.current;
                    const s = Math.min(clientWidth/w, clientHeight/h) * 0.95;
                    setTransform({ x: (clientWidth - w*s)/2, y: (clientHeight - h*s)/2, scale: s });
                }
            }, [layer, colormapName]);

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas || !layer) return;
                const ctx = canvas.getContext('2d');
                const [h, w] = layer.dims;
                const viewDiv = viewRef.current;
                if (!viewDiv) return;
                
                canvas.width = viewDiv.clientWidth;
                canvas.height = viewDiv.clientHeight;

                ctx.save();
                ctx.fillStyle = '#222'; ctx.fillRect(0,0,canvas.width, canvas.height);
                ctx.translate(transform.x, transform.y); ctx.scale(transform.scale, transform.scale);
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(offscreenCanvasRef.current, 0, 0);

                if (overlaySettings.visible && spatialIndex) {
                    ctx.strokeStyle = overlaySettings.color;
                    ctx.lineWidth = overlaySettings.width / transform.scale;
                    
                    const drawFeats = (feats, isBoundary) => {
                        if(!feats) return;
                        const { minLat, maxLat, minLon, maxLon } = spatialIndex.domain;
                        if (isBoundary) ctx.lineWidth = (overlaySettings.width / 2) / transform.scale;
                        
                        ctx.beginPath();
                        for (let fIdx = 0; fIdx < feats.length; fIdx++) {
                            const f = feats[fIdx];
                            if (!f || !f.geometry || !f.geometry.type) continue; 
                            const polys = f.geometry.type === 'Polygon' ? [f.geometry.coordinates] : f.geometry.coordinates;
                            if (!polys) continue;
                            
                            for (let pIdx = 0; pIdx < polys.length; pIdx++) {
                                const p = polys[pIdx];
                                if (!p) continue;
                                for (let rIdx = 0; rIdx < p.length; rIdx++) {
                                    const ring = p[rIdx];
                                    if (!ring) continue;
                                    let first = true;
                                    for (let ptIdx = 0; ptIdx < ring.length; ptIdx++) {
                                        const pt = ring[ptIdx];
                                        // Fast rejection padded by 2 degrees
                                        if (pt[1] < minLat - 2 || pt[1] > maxLat + 2 || pt[0] < minLon - 2 || pt[0] > maxLon + 2) {
                                            first = true;
                                            continue;
                                        }
                                        const px = findClosestPixel(pt[1], pt[0], spatialIndex);
                                        if (px) { 
                                            if(first) { ctx.moveTo(px.x, px.y); first=false; } 
                                            else ctx.lineTo(px.x, px.y); 
                                        } else {
                                            first = true;
                                        }
                                    }
                                }
                            }
                        }
                        ctx.stroke();
                    };
                    drawFeats(coastlineData, false);
                    ctx.strokeStyle = `${overlaySettings.color}99`;
                    drawFeats(boundaryData, true);
                }
                ctx.restore();
            }, [layer, transform, coastlineData, boundaryData, overlaySettings, spatialIndex]);

            // Draw Decoupling: Store a ref to the latest draw method
            const drawRef = useRef(draw);
            useEffect(() => { drawRef.current = draw; }, [draw]);
            
            // Re-draw when dependencies (like transform) change
            useEffect(() => { draw(); }, [draw]);

            // The ResizeObserver is now empty-deps, preventing the choking effect that broke panning
            useEffect(() => {
                const viewDiv = viewRef.current;
                if (!viewDiv) return;
                const obs = new ResizeObserver(() => {
                    if (drawRef.current) drawRef.current();
                });
                obs.observe(viewDiv);
                return () => { obs.unobserve(viewDiv); };
            }, []);

            const handleMouse = (e) => {
                if (toolMode === 'pan') {
                    if (e.type === 'mousedown') { 
                        if (e.target.closest('div[style*="cursor: move"]')) return;
                        isPanning.current = true; 
                        setCursorPanning(true);
                        lastPos.current = { x: e.clientX, y: e.clientY }; 
                    }
                    else if (e.type === 'mouseup' || e.type === 'mouseleave') { 
                        isPanning.current = false; 
                        setCursorPanning(false);
                    }
                    else if (e.type === 'mousemove' && isPanning.current) {
                        const dx = e.clientX - lastPos.current.x;
                        const dy = e.clientY - lastPos.current.y;
                        setTransform(t => ({ ...t, x: t.x + dx, y: t.y + dy }));
                        lastPos.current = { x: e.clientX, y: e.clientY };
                    }
                } else if (e.type === 'click' && toolMode === 'picker') {
                    if (e.target.closest('div[style*="cursor: move"]')) return;
                    const rect = canvasRef.current.getBoundingClientRect();
                    const ix = Math.floor((e.clientX - rect.left - transform.x) / transform.scale);
                    const iy = Math.floor((e.clientY - rect.top - transform.y) / transform.scale);
                    const [h, w] = layer.dims;
                    if (ix>=0 && ix<w && iy>=0 && iy<h) {
                        const idx = iy * w + ix;
                        onPixelPick({
                            layerTitle: layer.title,
                            value: layer.values[idx],
                            units: layer.units,
                            lat: layer.coords?.lats[idx],
                            lon: layer.coords?.lons[idx],
                            pixel: { x: ix, y: iy }
                        });
                    }
                }
            };

            const handleWheel = (e) => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 0.95 : 1.05;
                setTransform(t => ({ ...t, scale: Math.max(0.1, t.scale * factor) }));
            };

            const handleExport = (scale) => {
                const [h, w] = layer.dims;
                const ew = Math.floor(w * scale), eh = Math.floor(h * scale);
                const out = document.createElement('canvas'); out.width=ew; out.height=eh;
                const ctx = out.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(offscreenCanvasRef.current, 0, 0, ew, eh);
                const link = document.createElement('a');
                link.download = `${layer.name}_export.png`;
                link.href = out.toDataURL();
                link.click();
            };

            const cbTitle = layer.units === '1' ? layer.name : (layer.units || 'N/A');

            return (
                <div className="view-container">
                    <div className="view-header">
                        <span className="view-header-title" title={layer.title || layer.name}>{layer.title || layer.name}</span>
                        {onRemove && onReorder && (
                            <div className="view-header-buttons">
                                <button className="view-btn" onClick={() => onReorder(layer.name, 'left')} disabled={index===0} title="Move Left">&larr;</button>
                                <button className="view-btn" onClick={() => onReorder(layer.name, 'right')} disabled={index===totalLayers-1} title="Move Right">&rarr;</button>
                                <button className="view-btn view-btn-close" onClick={() => onRemove(layer.name)} title="Close View">&times;</button>
                            </div>
                        )}
                    </div>
                    <div ref={viewRef} className="view-canvas-wrapper" onMouseDown={handleMouse} onMouseMove={handleMouse} onMouseUp={handleMouse} onMouseLeave={handleMouse} onClick={handleMouse} style={{cursor: toolMode==='pan'? (cursorPanning?'grabbing':'grab') : 'crosshair'}} onWheel={handleWheel}>
                        <canvas ref={canvasRef} style={{position:'absolute', top:0, left:0, pointerEvents:'none'}} />
                        <PanZoomControls onPan={(dx, dy)=>setTransform(t=>({...t, x: t.x+dx, y:t.y+dy}))} onZoom={f=>setTransform(t=>({...t, scale: f===1?1:t.scale*f}))} toolMode={toolMode} onSetToolMode={onSetToolMode} overlaySettings={overlaySettings} onUpdateOverlay={s=>setOverlaySettings(prev=>({...prev, ...s}))} colorMap={colormapName} onSetColorMap={onSetColorMap} isColorbarVisible={isCbVisible} onToggleColorbar={()=>setIsCbVisible(!isCbVisible)} colorbarPosition={cbPos} onSetColorbarPosition={setCbPos} onExport={handleExport} fullDims={layer.dims} parentRef={viewRef} />
                        {isCbVisible && <Colorbar units={cbTitle} colormapName={colormapName} min={domain.min} max={domain.max} position={cbPos} />}
                    </div>
                </div>
            );
        }

        // --- MAIN APP ---

        function App() {
            const notifier = useNotifier();
            const [ready, setReady] = useState(false);
            const [sources, setSources] = useState({});
            const [layers, setLayers] = useState([]);
            const [loading, setLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('Loading...');
            const [downloadProgress, setDownloadProgress] = useState(0);
            const [toolMode, setToolMode] = useState('pan');
            const [colorMap, setColorMap] = useState('grayscale');
            const [pixelInfo, setPixelInfo] = useState(null);
            const [metaView, setMetaView] = useState(null);
            const [coastline, setCoastline] = useState(null);
            const [boundaries, setBoundaries] = useState(null);
            const [special, setSpecial] = useState({ lat:false, lon:false, map:false });

            useEffect(() => {
                h5wasm.ready.then(() => {
                    setReady(true);
                    const params = new URLSearchParams(window.location.search);
                    const fileUrl = params.get('fileUrl');
                    if (fileUrl) fetchFileUrl(fileUrl);
                });
                
                const loadMaps = async () => {
                    try {
                        const [worldRes, usRes] = await Promise.all([
                            fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json'),
                            fetch('https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json') // Added US States boundaries
                        ]);
                        const world = await worldRes.json();
                        const us = await usRes.json();
                        
                        setCoastline([topojson.feature(world, world.objects.land)]);
                        const countries = topojson.feature(world, world.objects.countries).features;
                        const states = topojson.feature(us, us.objects.states).features;
                        setBoundaries([...countries, ...states]);
                    } catch (err) {
                        console.error("[App] Map Atlas Load Error:", err);
                    }
                };
                loadMaps();
            }, []);

            const fetchFileUrl = async (url, explicitName = null, initialVar = null) => {
                const fileName = explicitName || url.split('/').pop() || 'download.nc';
                setLoadingMessage(`Downloading: ${fileName}`);
                setIsLoading(true);
                setDownloadProgress(0);
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    
                    const reader = response.body.getReader();
                    const contentLength = +response.headers.get('Content-Length');
                    let receivedLength = 0;
                    let chunks = [];
                    
                    while(true) {
                        const {done, value} = await reader.read();
                        if (done) break;
                        chunks.push(value);
                        receivedLength += value.length;
                        if (contentLength) setDownloadProgress(Math.round((receivedLength / contentLength) * 100));
                    }

                    let chunksAll = new Uint8Array(receivedLength);
                    let position = 0;
                    for(let chunk of chunks) { chunksAll.set(chunk, position); position += chunk.length; }
                    
                    setDownloadProgress(0);
                    await handleUpload(chunksAll.buffer, fileName, initialVar);
                } catch (error) {
                    notifier.error(`Failed to load URL: ${error.message}`);
                    setIsLoading(false);
                }
            };

            const handleConfigLoaded = (config) => {
                if (config.url) {
                    fetchFileUrl(config.url, config.layerName, config.primaryVariable);
                }
            };

            const handleUpload = async (buf, name, initialVar = null) => {
                setLoadingMessage(`Processing Metadata for ${name}...`);
                setLoading(true);
                try {
                    const id = `f${Date.now()}`;
                    h5wasm.FS.writeFile(id, new Uint8Array(buf));
                    const f = new h5wasm.File(id, 'r');
                    const root = f.get('/');
                    const vars = [];
                    
                    // PDF Implementation: Extract full attributes dynamically
                    const scan = (g) => {
                        for (let k of g.keys()) {
                            const it = g.get(k);
                            if (it instanceof h5wasm.Group) scan(it);
                            else if (it.shape && it.shape.length === 2) {
                                vars.push({ 
                                    name: k, 
                                    shape: it.shape, 
                                    dtype: it.dtype, 
                                    attributes: extractAttributes(it),
                                    units: (it.attrs && it.attrs.units) ? it.attrs.units.value : 'N/A'
                                });
                            }
                        }
                    };
                    scan(root);
                    
                    const globalAttrs = extractAttributes(root);
                    const meta = { variables: vars, globalAttributes: globalAttrs, fileBuffer: buf, isGeospatial: false };
                    
                    const proj = findVar(h5wasm, root, 'goes_imager_projection');
                    if (proj) {
                        setLoadingMessage('Computing Geospatial Coordinates...');
                        const x = findVar(h5wasm, root, 'x');
                        const y = findVar(h5wasm, root, 'y');
                        if (x && y) {
                            const geoData = { globalAttributes: extractAttributes(proj), variables: { x:{data: unpack(x,false)}, y:{data: unpack(y,false)} } };
                            const coords = await geoService.process(geoData);
                            meta.coords = coords;
                            meta.isGeospatial = true;
                            meta.latLonDomain = { lat: getDomain(coords.lats), lon: getDomain(coords.lons) };
                        }
                    }
                    
                    setSources(prev => ({ ...prev, [name]: meta }));
                    f.close(); h5wasm.FS.unlink(id);
                    notifier.success(`Loaded ${name}`);
                    
                    if (initialVar || vars.length > 0) {
                        addLayer(meta, name, initialVar || vars[0].name);
                    }
                } catch (e) { 
                    notifier.error(e.message); 
                }
                setLoading(false);
            };

            const addLayer = async (sourceMeta, srcName, varName) => {
                if (layers.some(l => l.name === varName)) return;
                setLoadingMessage(`Loading Layer: ${varName}...`);
                setLoading(true);
                const id = `v${Date.now()}`;
                try {
                    h5wasm.FS.writeFile(id, new Uint8Array(sourceMeta.fileBuffer));
                    const f = new h5wasm.File(id, 'r');
                    const v = findVar(h5wasm, f.get('/'), varName);
                    if (!v) throw new Error("Variable not found");
                    const attrs = extractAttributes(v);
                    const layer = {
                        name: varName, title: `${srcName} - ${varName}`,
                        values: unpack(v, true), dims: v.shape, units: attrs.units || 'N/A',
                        attributes: attrs, coords: sourceMeta.coords,
                        tech: { dtype: v.dtype, shape: v.shape }
                    };
                    setLayers(prev => [...prev, layer]);
                    f.close(); h5wasm.FS.unlink(id);
                } catch(e) {
                    notifier.error(e.message);
                }
                setLoading(false);
            };

            const handleShowMetadata = (e, title, data, tech = null) => {
                e.stopPropagation();
                setMetaView({ title, data, tech });
            };

            const geoSource = useMemo(() => Object.values(sources).find(s => s.isGeospatial), [sources]);
            const geoSourceDims = geoSource && geoSource.variables.length > 0 ? geoSource.variables[0].shape : null;
            const hasGoesData = !!geoSource;

            if (!ready) return <div className="loading-overlay">Initializing Engine...</div>;

            return (
                <div className="main-layout">
                    <div className="sidebar">
                        <h3>Controls</h3>
                        <Uploader onNcFileLoaded={(buf, name) => handleUpload(buf, name)} onConfigLoaded={handleConfigLoaded} />
                        
                        <div style={{border:'1px solid #ccc', padding:'10px', borderRadius:'4px', marginTop:'1rem'}}>
                            <h4 style={{marginTop:0, marginBottom:'10px'}}>Data &amp; Layers</h4>
                            {Object.entries(sources).length === 0 ? <p>No data sources loaded.</p> : null}
                            {Object.entries(sources).map(([name, src]) => (
                                <div key={name}>
                                    <div style={{background:'#f0f2f5', padding:'8px 12px', borderBottom:'1px solid #ddd', fontWeight:'bold', fontSize:'1rem', display:'flex', justifyContent:'space-between'}}>
                                        <span style={{overflow:'hidden', textOverflow:'ellipsis', whiteSpace:'nowrap', maxWidth:'200px'}}>{name}</span>
                                        <span className="info-icon" title="Global Attributes" onClick={(e)=>handleShowMetadata(e, name, src.globalAttributes, { type: 'File Group' })}>ⓘ</span>
                                    </div>
                                    <div style={{padding:'5px 0'}}>
                                        {src.variables.map(v => {
                                            const isActive = layers.some(l => l.name === v.name);
                                            return (
                                                <div key={v.name} style={{display:'flex', justifyContent:'space-between', alignItems:'center', padding:'6px 12px', cursor:'pointer', borderRadius:'3px', marginBottom:'2px', backgroundColor: isActive ? '#e7f5ff' : 'transparent'}} onClick={() => !isActive && addLayer(src, name, v.name)}>
                                                    <span style={{fontWeight: isActive ? 'bold' : 'normal', overflow:'hidden', textOverflow:'ellipsis', whiteSpace:'nowrap', maxWidth:'200px'}}>{v.name}</span>
                                                    <div style={{display:'flex', gap:'5px', alignItems:'center'}}>
                                                        <span className="info-icon" title="Dataset Metadata" onClick={(e)=>handleShowMetadata(e, v.name, v.attributes, { dtype: v.dtype, shape: v.shape })}>ⓘ</span>
                                                        {isActive && <div style={{cursor:'pointer', color:'#a00', fontWeight:'bold', borderRadius:'50%', width:'20px', height:'20px', display:'flex', alignItems:'center', justifyContent:'center', border:'1px solid #fcc', background:'#fff0f0'}} onClick={(e)=>{e.stopPropagation(); setLayers(prev=>prev.filter(x=>x.name!==v.name));}}>&times;</div>}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            ))}

                            <div style={{marginTop:'20px'}}>
                                <h4 style={{borderTop:'1px solid #ddd', paddingTop:'15px', marginBottom:'10px'}}>Derived Views</h4>
                                <button style={{display:'block', width:'100%', padding:'8px', marginTop:'5px', textAlign:'left', border:'1px solid #ced4da', borderRadius:'4px', cursor:'pointer', background: special.lat ? '#cce5ff' : '#e9ecef'}} onClick={()=>setSpecial(s=>({...s, lat:!s.lat}))}>Latitude Raster</button>
                                <button style={{display:'block', width:'100%', padding:'8px', marginTop:'5px', textAlign:'left', border:'1px solid #ced4da', borderRadius:'4px', cursor:'pointer', background: special.lon ? '#cce5ff' : '#e9ecef'}} onClick={()=>setSpecial(s=>({...s, lon:!s.lon}))}>Longitude Raster</button>
                                <button style={{display:'block', width:'100%', padding:'8px', marginTop:'5px', textAlign:'left', border:'1px solid #ced4da', borderRadius:'4px', cursor:'pointer', background: special.map ? '#cce5ff' : '#e9ecef'}} onClick={()=>setSpecial(s=>({...s, map:!s.map}))}>Map Overlay</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style={{ display: 'flex', flexDirection: 'column', flexGrow: 1, backgroundColor: '#e9ecef' }}>
                        <div className="content-grid" style={{ flexGrow: 1 }}>
                            {layers.map((l, i) => (
                                <InteractiveDataView key={`${l.name}-${i}`} layer={l} colormapName={colorMap} onSetColorMap={setColorMap} coastlineData={coastline} boundaryData={boundaries} toolMode={toolMode} onSetToolMode={setToolMode} onPixelPick={setPixelInfo} onRemove={n => setLayers(prev => prev.filter(x => x.name !== n))} onReorder={(n, d) => {
                                    const idx = layers.findIndex(x => x.name === n);
                                    const next = d === 'left' ? idx - 1 : idx + 1;
                                    const copy = [...layers]; [copy[idx], copy[next]] = [copy[next], copy[idx]];
                                    setLayers(copy);
                                }} index={i} totalLayers={layers.length} />
                            ))}
                            {special.lat && geoSource && geoSourceDims && (
                                <InteractiveDataView layer={{ name: 'lat', title: 'Calculated Latitude', values: geoSource.coords.lats, dims: geoSourceDims, domain: geoSource.latLonDomain.lat, units: 'Degrees', coords: geoSource.coords }} colormapName={colorMap} onSetColorMap={setColorMap} coastlineData={coastline} boundaryData={boundaries} toolMode={toolMode} onSetToolMode={setToolMode} onPixelPick={setPixelInfo} onRemove={()=>setSpecial(s=>({...s, lat:false}))} onReorder={()=>null} index={0} totalLayers={1} />
                            )}
                            {special.lon && geoSource && geoSourceDims && (
                                <InteractiveDataView layer={{ name: 'lon', title: 'Calculated Longitude', values: geoSource.coords.lons, dims: geoSourceDims, domain: geoSource.latLonDomain.lon, units: 'Degrees', coords: geoSource.coords }} colormapName={colorMap} onSetColorMap={setColorMap} coastlineData={coastline} boundaryData={boundaries} toolMode={toolMode} onSetToolMode={setToolMode} onPixelPick={setPixelInfo} onRemove={()=>setSpecial(s=>({...s, lon:false}))} onReorder={()=>null} index={0} totalLayers={1} />
                            )}
                            {special.map && geoSource && geoSourceDims && (
                                <InteractiveDataView layer={{ name: 'map_overlay', title: 'Map Overlay', values: new Float32Array(geoSource.coords.lats.length).fill(1), dims: geoSourceDims, domain: {min:0, max:1}, units: 'Overlay', coords: geoSource.coords }} colormapName="grayscale" onSetColorMap={()=>null} coastlineData={coastline} boundaryData={boundaries} toolMode={toolMode} onSetToolMode={setToolMode} onPixelPick={setPixelInfo} onRemove={()=>setSpecial(s=>({...s, map:false}))} onReorder={()=>null} index={0} totalLayers={1} />
                            )}
                        </div>
                        {hasGoesData && (
                            <div style={{ textAlign: 'center', padding: '4px' }}>
                                <span className="attribution-text">Data from NOAA's Geostationary Operational Environmental Satellites (GOES)-R Series</span>
                            </div>
                        )}
                    </div>
                    
                    {loading && (
                        <div className="loading-overlay">
                            <div className="loading-content">
                                <div>{loadingMessage}</div>
                                {downloadProgress > 0 && (
                                    <div className="progress-bar-container">
                                        <div className="progress-bar" style={{ width: `${downloadProgress}%` }}>{downloadProgress}%</div>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                    
                    {pixelInfo && (
                        <div style={{position:'fixed', top:'20px', right:'20px', background:'rgba(255, 255, 255, 0.95)', border:'1px solid #ccc', padding:'1rem', borderRadius:'5px', boxShadow:'0 4px 12px rgba(0,0,0,0.2)', zIndex:5000, fontSize:'0.9rem', width:'260px'}}>
                            <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'0.75rem', fontSize:'1.1rem', color:'#495057'}}>
                                <span style={{fontWeight:'bold'}}>Pixel Inspector</span>
                                <button onClick={()=>setPixelInfo(null)} style={{background:'none',border:'none',fontSize:'1.5rem',lineHeight:'1',cursor:'pointer',padding:'0 0 0 1rem',color:'#888'}}>&times;</button>
                            </div>
                            <div style={{display:'flex', justifyContent:'space-between', padding:'0.25rem 0'}}><span style={{color:'#6c757d'}}>Layer:</span><span style={{fontWeight:'bold', color:'#212529'}}>{pixelInfo.layerTitle}</span></div>
                            <div style={{display:'flex', justifyContent:'space-between', padding:'0.25rem 0'}}><span style={{color:'#6c757d'}}>Value:</span><span style={{fontWeight:'bold', color:'#212529'}}>{pixelInfo.value?.toFixed(4)} {pixelInfo.units}</span></div>
                            <div style={{display:'flex', justifyContent:'space-between', padding:'0.25rem 0'}}><span style={{color:'#6c757d'}}>Latitude:</span><span style={{fontWeight:'bold', color:'#212529'}}>{pixelInfo.lat ? pixelInfo.lat.toFixed(4) + '°' : 'N/A'}</span></div>
                            <div style={{display:'flex', justifyContent:'space-between', padding:'0.25rem 0'}}><span style={{color:'#6c757d'}}>Longitude:</span><span style={{fontWeight:'bold', color:'#212529'}}>{pixelInfo.lon ? pixelInfo.lon.toFixed(4) + '°' : 'N/A'}</span></div>
                            <div style={{display:'flex', justifyContent:'space-between', padding:'0.25rem 0'}}><span style={{color:'#6c757d'}}>Pixel (X,Y):</span><span style={{fontWeight:'bold', color:'#212529'}}>{pixelInfo.pixel.x}, {pixelInfo.pixel.y}</span></div>
                        </div>
                    )}
                    
                    <MetadataModal view={metaView} onClose={()=>setMetaView(null)} />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<NotificationProvider><App /></NotificationProvider>);
    </script>
</body>
</html>
